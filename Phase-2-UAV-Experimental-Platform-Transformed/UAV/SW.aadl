package SW
public
	with Drivers;
	with Waterways_UxAS;
	with CASE_Model_Transformations;
	with CASEAgree;
	with CASEConsts;
	with WaypointPlanManagerService_Pkg;
	with CASE_Properties;
	with CMASI;
	with Base_Types;
    renames AGREE_PLTL::all;

	thread CASE_Monitor_Geo
		features
			observed: in event data port CMASI::AutomationResponse.i;
			keep_in_zones: in data port CMASI::Polygon.i;
			keep_out_zones: in data port CMASI::Polygon.i;
			output: out event data port CMASI::AutomationResponse.i;
			alert: out event port; 
		properties
			CASE_Properties::Component_Type => MONITOR;                             -- marks this component as a monitor
            CASE_Properties::Component_Spec => ("Req001_GeofenceMonitorEvent");     -- monitor guarantee
            CASE_Properties::Monitor_Latched => true;                               -- indicates if the monitor is latched
    
		annex agree {**
            -- a constant generated from the component property above, handy for expressing the monitor guarantee
            const is_latched : bool = Get_Property(this, CASE_Properties::Monitor_Latched);
            
            property CASE_Monitor_Coord_policy = Historically(event(observed) => (WAYPOINTS_OK(GET_MISSION_COMMAND(observed), keep_in_zones, keep_out_zones)));
            
            -- Monitor guarantee
            -- Note: user specifies when output is sent; either when the monitor policy is satisfied or its negation.
            guarantee Req001_GeoMonitorEvent "The output event only fires when observed is valid" :
                if is_latched and prev(event(alert), not CASE_Monitor_Coord_policy) then
                    event(alert) = true and not event(output)
                else
                    if event(observed) then
                        if CASE_Monitor_Coord_policy then
                            event(output) and output = observed and not event(alert)
                            -- event(ouput) = true ; output = observed ; event(alert) = false
                        else
                            not event(output) and event(alert)
                            -- event(ouput) = false; event(alert) = true
                    else
                        not event(output) and not event(alert);
                        -- event(ouput) = false; event(alert) = false
                            
            guarantee Req001_GeoFenceMonitor "The monitor only fires when the observed is valid" :
              if (event(observed) and CASE_Monitor_Coord_policy) then
                event(output) and output = observed and event(alert)
              else
                not event(output) and not event(alert);
            
            fun GET_MISSION_COMMAND(automationResponse: CMASI::AutomationResponse.i) : CMASI::MissionCommand.i =
              automationResponse.MissionCommandList[0];
               
            fun WAYPOINTS_OK(mission : CMASI::MissionCommand.i, keepInZone : CMASI::Polygon.i, KeepOutZone : CMASI::Polygon.i) : bool =
              forall waypoint in mission.WaypointList, WAYPOINT_IN_ZONE_RECTANGLE(waypoint, keepInZone) and not WAYPOINT_IN_ZONE_RECTANGLE(waypoint, keepOutZone);
              
            -- Assumes rectangle that is defined by two corners so it is aligned
            -- with the origin (not rotated in space)
            -- Assumes that the altitude is the same in all the coordinates
            -- Assmes zone[0] is the bottom left corner and zone[2] in the upper right corner
            fun WAYPOINT_IN_ZONE_RECTANGLE(waypoint : CMASI::Waypoint.i, zone : CMASI::Polygon.i) : bool =
                  (waypoint.Latitude >= (zone.BoundaryPointsList[0]).Latitude)
              and (waypoint.Latitude <= (zone.BoundaryPointsList[1]).Latitude)
              and (waypoint.Longitude >= (zone.BoundaryPointsList[0]).Longitude)
              and (waypoint.Longitude <= (zone.BoundaryPointsList[1]).Longitude)
              and (waypoint.Altitude >= (zone.BoundaryPointsList[0]).Altitude);
        **};
	end CASE_Monitor_Geo;

	thread implementation CASE_Monitor_Geo.Impl
		properties
			Dispatch_Protocol => Periodic;
	end CASE_Monitor_Geo.Impl;

	thread CASE_Filter_UxAS
		features
			filter_in: in event data port CMASI::AutomationResponse.i;
			filter_out: out event data port CMASI::AutomationResponse.i;
		properties
			CASE_Properties::Component_Type => FILTER;
			CASE_Properties::Component_Spec => ("Req_Filter_ARes");
		annex agree {**
			guarantee Req_Filter_ARes "Well-formed Automation Response message" : CASEAgree::WELL_FORMED_AUTOMATION_RESPONSE(filter_out);
		**};
	end CASE_Filter_UxAS;

	thread implementation CASE_Filter_UxAS.Impl
		properties
			Dispatch_Protocol => Periodic;
	end CASE_Filter_UxAS.Impl;

	thread CASE_Monitor_Req
		features
			observed: in event data port CMASI::AutomationResponse.i;
			reference_1: in event data port CMASI::AutomationRequest.i;
			alert: out event data port Base_Types::Boolean;
		properties
			CASE_Properties::Component_Type => MONITOR;
			CASE_Properties::Component_Spec => ("monitor_policy");
		annex agree {**
		    const is_latched : bool = true;
		    -- AutomationResponse (observed) occurs exactly two scheduling cycles after AutomationRequest (reference_1)
            property CASE_Monitor_Req_policy = Historically(Yesterday(Yesterday(event(reference_1))) => event(observed));
            
            guarantee monitor_policy "The monitor shall only output an alert when the monitor policy is true" :
              if (is_latched and prev(alert, not CASE_Monitor_Req_policy)) then
                  true
              else 
                  not CASE_Monitor_Req_policy;                 
		**};
	end CASE_Monitor_Req;

	thread implementation CASE_Monitor_Req.Impl
		properties
			Dispatch_Protocol => Periodic;
	end CASE_Monitor_Req.Impl;

	thread CASE_Filter_LST
		features
			filter_in: in event data port CMASI::LineSearchTask.i;
			filter_out: out event data port CMASI::LineSearchTask.i;
		properties
			CASE_Properties::Component_Type => FILTER;
			CASE_Properties::Component_Spec => ("Req_Filter_LST");
		annex agree {**
			guarantee Req_Filter_LST "Well-formed Line Search Task message" : CASEAgree::WELL_FORMED_LINE_SEARCH_TASK(filter_out);
		**};
	end CASE_Filter_LST;

	thread implementation CASE_Filter_LST.Impl
		properties
			Dispatch_Protocol => Periodic;
	end CASE_Filter_LST.Impl;

	thread CASE_Filter_OR
		features
			filter_in: in event data port CMASI::OperatingRegion.i;
			filter_out: out event data port CMASI::OperatingRegion.i;
		properties
			CASE_Properties::Component_Type => FILTER;
			CASE_Properties::Component_Spec => ("Req_Filter_OR");
		annex agree {**
			guarantee Req_Filter_OR "Well-formed Operating Region message" : CASEAgree::WELL_FORMED_OPERATING_REGION(filter_out);
		**};
	end CASE_Filter_OR;

	thread implementation CASE_Filter_OR.Impl
		properties
			Dispatch_Protocol => Periodic;
	end CASE_Filter_OR.Impl;

	thread CASE_Filter_AR
		features
			filter_in: in event data port CMASI::AutomationRequest.i;
			filter_out: out event data port CMASI::AutomationRequest.i;
		properties
			CASE_Properties::Component_Type => FILTER;
			CASE_Properties::Component_Spec => ("Req_Filter_AReq");
		annex agree {**
			guarantee Req_Filter_AReq "Well-formed Automation Request message" : CASEAgree::WELL_FORMED_AUTOMATION_REQUEST(filter_out);
		**};
	end CASE_Filter_AR;

	thread implementation CASE_Filter_AR.Impl
		properties
			Dispatch_Protocol => Periodic;
	end CASE_Filter_AR.Impl;

	thread CASE_AttestationManager
		features
			am_AutomationRequest_in: in event data port CMASI::AutomationRequest.i;
			am_AutomationRequest_out: out event data port CMASI::AutomationRequest.i;
			am_OperatingRegion_in: in event data port CMASI::OperatingRegion.i;
			am_OperatingRegion_out: out event data port CMASI::OperatingRegion.i;
			am_LineSearchTask_in: in event data port CMASI::LineSearchTask.i;
			am_LineSearchTask_out: out event data port CMASI::LineSearchTask.i;
			am_request: out event data port CASE_Model_Transformations::CASE_AttestationRequestMsg.Impl;
			am_response: in event data port CASE_Model_Transformations::CASE_AttestationResponseMsg.Impl;
		properties
			CASE_Properties::Component_Type => ATTESTATION;
	end CASE_AttestationManager;

	thread implementation CASE_AttestationManager.Impl
		properties
			CASE_Properties::Component_Impl => "CakeML";
			CASE_Properties::Cache_Timeout => 30;
			CASE_Properties::Cache_Size => 4;
			Dispatch_Protocol => Periodic;
	end CASE_AttestationManager.Impl;

	thread RadioDriver_Attestation extends Drivers::RadioDriver
		features
			am_request: in event data port CASE_Model_Transformations::CASE_AttestationRequestMsg.Impl;
			am_response: out event data port CASE_Model_Transformations::CASE_AttestationResponseMsg.Impl;
--			comm_request: out event data port CASE_Model_Transformations::CASE_AttestationRequestMsg.Impl;
--			comm_response: in event data port CASE_Model_Transformations::CASE_AttestationResponseMsg.Impl;
--			alert: in event data port Base_Types::Boolean;
	end RadioDriver_Attestation;

	thread implementation RadioDriver_Attestation.Impl extends Drivers::RadioDriver.Impl
	end RadioDriver_Attestation.Impl;

	thread FlyZonesDatabase
		-- The KeepInZoneDatabase is a collection of polygons that represent areas on a map that the UAV can traverse.
		-- The database is populated at build-time and stored in memory.
		features
			keep_in_zones: out data port CMASI::Polygon.i;
			keep_out_zones: out data port CMASI::Polygon.i;
	end FlyZonesDatabase;

	thread implementation FlyZonesDatabase.Impl
		properties
			Dispatch_Protocol => Periodic;
	end FlyZonesDatabase.Impl;

	process SW
		features
			uart_recv: in event data port CASE_Model_Transformations::CASE_UART_Msg.Impl;
			uart_send: out event data port CASE_Model_Transformations::CASE_UART_Msg.Impl;
			radio_recv: in event data port CASE_Model_Transformations::CASE_RF_Msg.Impl;
			radio_send: out event data port CASE_Model_Transformations::CASE_RF_Msg.Impl;

		annex agree {**
			guarantee Req001_SW "The radio_send outputs only well formed CASE_RF_Msg.Impl types" : CASEAgree::WellformedCASE_RF_Msg(radio_send, CASEConsts::UAV_ID, CASEConsts::GS_ID);
			guarantee Req002_SW "The uart_send outputs only well formed CASE_RF_Msg.Impl types" : CASEAgree::WellformedCASE_UART_Msg(uart_send);
		**};

	end SW;

	process implementation SW.Impl
		subcomponents
			FC_UART: thread Drivers::UARTDriver.Impl;
			RADIO: thread RadioDriver_Attestation.Impl;
			FlyZones: thread FlyZonesDatabase.Impl;
			UXAS: thread group Waterways_UxAS::Waterways.i;
			WPM: thread WaypointPlanManagerService_Pkg::WaypointPlanManagerService.i;
			AM: thread CASE_AttestationManager.Impl;
			FLT_AR: thread CASE_Filter_AR.Impl;
			FLT_OR: thread CASE_Filter_OR.Impl;
			FLT_LST: thread CASE_Filter_LST.Impl;
			MON_REQ: thread CASE_Monitor_Req.Impl;
			FLT_UXAS: thread CASE_Filter_UxAS.Impl;
			MON_GEO: thread CASE_Monitor_Geo.Impl;
		connections
			------------------
			-- Primary Inputs
			------------------
			c01: port uart_recv -> FC_UART.recv_data;
			c02: port radio_recv -> RADIO.recv_data;

			----------- 	           
			-- FC_UART
			-----------
			c03: port FC_UART.send_data -> uart_send;
			c04: port FC_UART.AirVehicleState -> UXAS.AirVehicleState;
--			c05: port FC_UART.AirVehicleState -> RADIO.AirVehicleState;
			c06: port FC_UART.AirVehicleState -> WPM.AirVehicleState;
--			c_t_08: port ??? -> FC_UART.MissionCommand;	-- HOW DOES FC_UART GET INITIALIZED?
			---------
			-- RADIO
			---------
			c07: port RADIO.send_data -> radio_send;
			c08: port RADIO.AutomationRequest -> AM.am_AutomationRequest_in;
			c09: port RADIO.OperatingRegion -> AM.am_OperatingRegion_in;
			c10: port RADIO.LineSearchTask -> AM.am_LineSearchTask_in;
			c11: port AM.am_request -> RADIO.am_request;
			c12: port RADIO.am_response -> AM.am_response;
			c13: port AM.am_AutomationRequest_out -> FLT_AR.filter_in;
			c14: port FLT_AR.filter_out -> UXAS.AutomationRequest;
			c15: port AM.am_OperatingRegion_out -> FLT_OR.filter_in;
			c16: port FLT_OR.filter_out -> UXAS.OperatingRegion;
			c17: port AM.am_LineSearchTask_out -> FLT_LST.filter_in;
			c18: port FLT_LST.filter_out -> UXAS.LineSearchTask;

			--------
			-- UXAS
			--------
--			c09: port UXAS.MissionCommand -> FC_UART.MissionCommand;
			c20: port UXAS.AutomationResponse -> RADIO.AutomationResponse;
			c21: port UXAS.AutomationResponse -> FLT_UXAS.filter_in;
			c22: port MON_GEO.output -> WPM.AutomationResponse;
			c23: port FlyZones.keep_in_zones -> MON_GEO.keep_in_zones;
			c29: port FlyZones.keep_out_zones -> MON_GEO.keep_out_zones;
			c24: port FLT_UXAS.filter_out -> MON_GEO.observed;
			c25: port MON_GEO.alert -> WPM.ReturnHome;
			c26: port FLT_AR.filter_out -> MON_REQ.reference_1;
			c27: port UXAS.AutomationResponse -> MON_REQ.observed;

			--------
			-- WPM
			--------
--			c_t_14: port ??? -> WPM.AirVehicleState;  -- HOW DOES WPM GET INITIALIZED?
			c28: port WPM.MissionCommand -> FC_UART.MissionCommand;

	end SW.Impl;
	
end SW;